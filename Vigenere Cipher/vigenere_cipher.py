# -*- coding: utf-8 -*-
"""VigenereCipher.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lBYvT75pCpVl57Jp-6PmW1y8XumfUGbG

# Vigenere Cipher
"""

class VigenereCipher:
  '''
  The Vigen√®re cipher is a method of encrypting alphabetic text by using a series of interwoven Caesar ciphers, 
  based on the letters of a keyword. It employs a form of polyalphabetic substitution.
  '''
  def __init__(self):
    self.alphabets = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    self.lookuptable = [[" " for __ in range(len(self.alphabets))] for _ in range(len(self.alphabets))]
    self.init_lookup_table()

  def init_lookup_table(self):
    '''
    Look Up Table Created During Initialization
    '''
    for i in range(len(self.alphabets)):
      for j in range(len(self.alphabets)):
        if 65 + i +j <= 90:
          self.lookuptable[i][j] = chr(65+j+i)
        else:
          self.lookuptable[i][j] = chr(64 + (65+j+i)%90)


  def print_lookup_table(self):
    for i in range(len(self.alphabets)):
      for j in range(len(self.alphabets)):
        print(self.lookuptable[i][j], end=" ")
      print("\n")


  def encrypt(self, plaintext, key):
    '''
    Encrypts the plaintext if length of key matches length of plaintext
    else extends the key to match the plaintext to fit this criteria
    Character to Character Encryption
    '''
    keystream = ""
    ciphertext = ""
    if len(plaintext) != len(key):
      i = 0
      for k in range(len(plaintext)):
        if plaintext[k] != " ":
          keystream += key[i]
          i = (i+1)%len(key)
        else:
          keystream += " "
    else:
      keystream = key
    for j in range(len(plaintext)):
      if plaintext[j] != " ":
        ciphertext += self.lookuptable[self.alphabets.find(keystream[j])][self.alphabets.find(plaintext[j])]
      else:
        ciphertext += " "
    return ciphertext
  

  def decrypt(self, ciphertext, key):
    '''
    Decrypts the ciphertext if length of key matches length of ciphertext
    else extends the key to match the ciphertext to fit this criteria
    Character to Character Decryption
    '''
    keystream = ""
    if len(ciphertext) != len(key):
      i = 0
      for k in range(len(ciphertext)):
        if ciphertext[k] != " ":
          keystream += key[i]
          i = (i+1)%len(key)
        else:
          keystream += " "
    else:
      keystream = key
    decrypted_msg = ""
    for j in range(len(ciphertext)):
      if ciphertext[j] != " ":
        pos = self.lookuptable[self.alphabets.find(keystream[j])].index(ciphertext[j])
        decrypted_msg += self.alphabets[pos]
      else:
        decrypted_msg += " "
    return decrypted_msg

vigenere_cipher = VigenereCipher()
message = "ATTACKATDAWN"
key  = "LEMON"
ciphertext = vigenere_cipher.encrypt(message, key)
ciphertext

received_message = vigenere_cipher.decrypt(ciphertext, key)
received_message

vigenere_cipher.encrypt("I LOOVE PEANUTS", "BANANA")

vigenere_cipher.decrypt(vigenere_cipher.encrypt("I LOOVE PEANUTS", "BANANA"), "BANANA")

vigenere_cipher.encrypt("THIS IS AMAZING", "HORRIBLE")

vigenere_cipher.decrypt(vigenere_cipher.encrypt("THIS IS AMAZING", "HORRIBLE"), "HORRIBLE")

vigenere_cipher.decrypt(vigenere_cipher.encrypt("THIS IS AMAZING", "HORRIBLE"), "BANANA")

vigenere_cipher.print_lookup_table()